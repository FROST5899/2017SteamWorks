package org.usfirst.frc.team5899.robot;
import org.opencv.core.Rect;
import org.opencv.imgproc.Imgproc;

import com.ctre.CANTalon;

import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.vision.VisionThread;



public class Vision {
	
	Object imgLock;
	/*
	private final Object imgLock = new Object();
	//vision stuff:
	private static final int IMG_WIDTH = 320;
	private static final int IMG_HEIGHT = 240;
	private VisionThread visionThread;*/
	private double Rect2 = 0.0;
	private double Rect1 = 0.0;
	private double Rect3 = 0.0;
	private double centerRect1;
	private double centerRect2;	
	double rectDistance = 0.0;
	String state = "";
	String DIR = "";
	RobotDrive drive;
	Encoder encoderLeft;
	Encoder encoderRight;
	double[] oldXValues;
	double[] newXValues;
	double firstTime = 0;
	public Vision(RobotDrive drive, Encoder encoderLeft, Encoder encoderRight, Object imageLock){
		this.imgLock = imageLock;
		this.drive = drive;
		this.encoderLeft = encoderLeft;
		this.encoderRight = encoderRight;
		
		
	}
	
	public void setRect(double R1, double R2) { //double R3) {
		this.Rect1 = R1;
		this.Rect2 = R2;
		//this.Rect3 = R3;
	}
	
/*	public void visionInit(){
	    UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
	    camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
	    
	    visionThread = new VisionThread(camera, new PracticePipeline(), pipeline -> {
	        if (!pipeline.filterContoursOutput().isEmpty()) {
	            Rect r1 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(0)); 
	        
	            if (pipeline.filterContoursOutput().size() > 1){
	            	Rect r2 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(1));
	            	synchronized (imgLock) {
	    	        	rectX1 = r1.x; // + (r1.width / 2);
	    	        	rectX2 = r2.x; //+ (r2.width / 2);
	    	        	centerX1 = r1.x + (r1.width / 2);
	    	        	centerX2 = r2.x + (r2.width / 2);
	            	}       
	    	   
	            } else {
	            	synchronized (imgLock) {
	    	        	rectX1 = r1.x; // + (r1.width / 2);
	    	        	rectX2 = rectX1;
	    	        	centerX1 = r1.x + (r1.width / 2);
	    	        	centerX2 = centerX1;
	            	}
	            }
	        }
	    });
	    visionThread.start();
	    
	}*/
	
	public  void scanX(){
		if(Timer.getFPGATimestamp() - Math.floor(Timer.getFPGATimestamp()) > 0.5){
			drive.arcadeDrive(-0.1, .4);
			//firstTimeScan = Timer.getFPGATimestamp();
		} else{
			drive.arcadeDrive(0,0);
		}
	}
	
	
	
	public void visionCases(String direction){
		
		this.DIR = direction;
		SmartDashboard.putString("visionState", state);
		SmartDashboard.putString("scanningDir", DIR);
		if (state == "scanning"){
			//firstTime = Timer.getFPGATimestamp();
			if (DIR == "left") {
				drive.tankDrive(0.3, -0.3);
				SmartDashboard.putBoolean("turning left", true);
				SmartDashboard.putBoolean("reached here", false);
				if (this.Rect1 != -1){
					state = "scanningForSecondContour";
				}
			}
			/*if (DIR == "right") {
				drive.tankDrive(-0.3, 0.3);
				SmartDashboard.putBoolean("turning right", true);
				SmartDashboard.putBoolean("reached here", false);
				if (newXValues != oldXValues){
					state = "scanningForSecondContour";
				}
			}*/

				SmartDashboard.putNumber("scanningValue1", Rect1);
				SmartDashboard.putNumber("scanningValue2", Rect2);
		
		}
		
		if(state == "scanningForSecondContour"){
			SmartDashboard.putBoolean("reached here", true);
		}
	}
	
}
