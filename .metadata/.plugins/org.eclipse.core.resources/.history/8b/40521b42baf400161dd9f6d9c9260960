package org.usfirst.frc.team5899.robot;
import org.opencv.core.Rect;
import org.opencv.imgproc.Imgproc;

import com.ctre.CANTalon;

import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.vision.VisionThread;



public class Vision {
	
	Object imgLock;
	/*
	private final Object imgLock = new Object();
	//vision stuff:
	private static final int IMG_WIDTH = 320;
	private static final int IMG_HEIGHT = 240;
	private VisionThread visionThread;*/
	private double Rect2 = 0.0;
	private double Rect1 = 0.0;
	private double Rect3 = 0.0;
	private double centerRect1;
	private double centerRect2;	
	double rectDistance = 0.0;
	
	public Vision(RobotDrive drive, Encoder encoderLeft, Encoder encoderRight, Object imageLock){
		this.imgLock = imageLock;
		
	}
	
	public void setRect(double R1, double R2, double R3) {
		this.Rect1 = R1;
		this.Rect2 = R2;
		this.Rect3 = R3;
	}
	
/*	public void visionInit(){
	    UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
	    camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
	    
	    visionThread = new VisionThread(camera, new PracticePipeline(), pipeline -> {
	        if (!pipeline.filterContoursOutput().isEmpty()) {
	            Rect r1 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(0)); 
	        
	            if (pipeline.filterContoursOutput().size() > 1){
	            	Rect r2 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(1));
	            	synchronized (imgLock) {
	    	        	rectX1 = r1.x; // + (r1.width / 2);
	    	        	rectX2 = r2.x; //+ (r2.width / 2);
	    	        	centerX1 = r1.x + (r1.width / 2);
	    	        	centerX2 = r2.x + (r2.width / 2);
	            	}       
	    	   
	            } else {
	            	synchronized (imgLock) {
	    	        	rectX1 = r1.x; // + (r1.width / 2);
	    	        	rectX2 = rectX1;
	    	        	centerX1 = r1.x + (r1.width / 2);
	    	        	centerX2 = centerX1;
	            	}
	            }
	        }
	    });
	    visionThread.start();
	    
	}*/
	
	public double[] scanX(){
		double[] xVals = {Rect1, Rect2};
			//SmartDashboard.putNumber("centerRect1 scanY", this.Rect1);
			//SmartDashboard.putNumber("centerRect2 scanY", this.Rect2);
		
		
		
		
		return xVals;		
	}
	
}
